<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>lessNote</title>
		<link rel="stylesheet" href="../css/blogs.css">
	</head>
	<body>
	  <h2>Less笔记</h2>
    <h3>变量</h3>
    <code>@color: #4D926F;</code><br>
    变量@color的值是#4D926F
    <h3>混合</h3>
    混合相当于定义一个函数，函数内写一些样式。在选择器内引入该函数就会拥有该函数内定义的所有样式。<br>
    <h4>简单的混合</h4>
    <pre>
.bordered {
  border-top: dotted 1px black;
  border-bottom: solid 2px black;
}
    </pre>
    当我想用.bordered中的样式时只需要写<code>.bordered;</code>就可以了，就像这样
    <pre>
#menu a {
  color: #111;
  .bordered;
}
.post a {
  color: red;
  .bordered;
}
    </pre>
    <h4>带参数的混合</h4>
    <pre>
.rounded-corners (@radius: 5px) {
  border-radius: @radius;
  -webkit-border-radius: @radius;
  -moz-border-radius: @radius;
}
#header {
  .rounded-corners;
}
#footer {
  .rounded-corners(10px);
}
    </pre>
    <code>.rounded-corners</code>相当于这个函数，该函数有一个默认的参数<code>@radius: 5px</code>，不带参数的引用就使用了该函数内样式的默认值，也可以传一个实参。
    <h3>嵌套规则</h3>
    在一个选择器中嵌套另一个选择器来实现继承<br>
    <pre>
#header {
  h1 {
    font-size: 26px;
    font-weight: bold;
  }
  p { font-size: 12px;
    a { text-decoration: none;
      &:hover { border-width: 1px }
    }
  }
}
    </pre>
    &相当于this，这里就是a
    <h3>运算</h3>
    任何数字、颜色或者变量都可以参与运算
    <h3>作用域</h3>
    首先从本地查找变量，没有的话就从父级查找，一直向上，直到找到为止。
    <h3>命名空间</h3>
    相当于对象，将一些变量和混合模块(函数)打包起来。好处是将函数封装了起来，只能通过外部的对象调用。
    <pre>
#bundle {
  .button () {
    display: block;
    border: 1px solid black;
    background-color: grey;
    &:hover { background-color: white }
  }
  .tab { ... }
  .citation { ... }
}
    </pre>
    当我需要使用某个混合模块的时候可以像这样引用
    <pre>
#header a {
  color: orange;
  #bundle > .button;
}
    </pre>
    就像调用<code>#bundle</code>对象的<code>.button</code>方法一样
    <h3>注释</h3>
    在less中不仅可以使用CSS注释，还可以使用//形式的注释，而且这种形式的注释在编译的时候会被自动过滤掉，即这种注释不会出现在编译后的CSS中，推荐使用//形式的注释。<br><br>
    <span class="time">2016-07-28 13:37:37</span>
	</body>
</html>
